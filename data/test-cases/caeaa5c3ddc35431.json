{"uid":"caeaa5c3ddc35431","name":"Image","fullName":"tests.test_elements.TestElements#test_image","historyId":"0e46d768fc18aeb978ea8d57478c9924","time":{"start":1714128000895,"stop":1714128003447,"duration":2552},"status":"failed","statusMessage":"AssertionError: ErrorElements.ERROR_FAVICON","statusTrace":"self = <pages.elements.broken_links.BrokenLinks object at 0x7f55d76257c0>\n\n    @allure.step(\"Checking the broken image\")\n    def check_broken_image(self):\n        imageSite = self.wait.until((EC.visibility_of_element_located(self.BROKEN_IMAGE)))\n        src = imageSite.get_attribute(\"src\")\n        response = requests.get(src)\n        try:\n            if response.status_code == 200:\n>               image = Image.open(BytesIO(response.content))\n\npages/elements/broken_links.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfp = <_io.BytesIO object at 0x7f55d64f61b0>, mode = 'r'\nformats = ['BMP', 'DIB', 'GIF', 'JPEG', 'PPM', 'PNG', ...]\n\n    def open(fp, mode=\"r\", formats=None) -> Image:\n        \"\"\"\n        Opens and identifies the given image file.\n    \n        This is a lazy operation; this function identifies the file, but\n        the file remains open and the actual image data is not read from\n        the file until you try to process the data (or call the\n        :py:meth:`~PIL.Image.Image.load` method).  See\n        :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n    \n        :param fp: A filename (string), pathlib.Path object or a file object.\n           The file object must implement ``file.read``,\n           ``file.seek``, and ``file.tell`` methods,\n           and be opened in binary mode. The file object will also seek to zero\n           before reading.\n        :param mode: The mode.  If given, this argument must be \"r\".\n        :param formats: A list or tuple of formats to attempt to load the file in.\n           This can be used to restrict the set of formats checked.\n           Pass ``None`` to try all supported formats. You can print the set of\n           available formats by running ``python3 -m PIL`` or using\n           the :py:func:`PIL.features.pilinfo` function.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        :exception FileNotFoundError: If the file cannot be found.\n        :exception PIL.UnidentifiedImageError: If the image cannot be opened and\n           identified.\n        :exception ValueError: If the ``mode`` is not \"r\", or if a ``StringIO``\n           instance is used for ``fp``.\n        :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.\n        \"\"\"\n    \n        if mode != \"r\":\n            msg = f\"bad mode {repr(mode)}\"\n            raise ValueError(msg)\n        elif isinstance(fp, io.StringIO):\n            msg = (\n                \"StringIO cannot be used to open an image. \"\n                \"Binary data must be used instead.\"\n            )\n            raise ValueError(msg)\n    \n        if formats is None:\n            formats = ID\n        elif not isinstance(formats, (list, tuple)):\n            msg = \"formats must be a list or tuple\"\n            raise TypeError(msg)\n    \n        exclusive_fp = False\n        filename = \"\"\n        if isinstance(fp, Path):\n            filename = str(fp.resolve())\n        elif is_path(fp):\n            filename = fp\n    \n        if filename:\n            fp = builtins.open(filename, \"rb\")\n            exclusive_fp = True\n    \n        try:\n            fp.seek(0)\n        except (AttributeError, io.UnsupportedOperation):\n            fp = io.BytesIO(fp.read())\n            exclusive_fp = True\n    \n        prefix = fp.read(16)\n    \n        preinit()\n    \n        accept_warnings = []\n    \n        def _open_core(fp, filename, prefix, formats):\n            for i in formats:\n                i = i.upper()\n                if i not in OPEN:\n                    init()\n                try:\n                    factory, accept = OPEN[i]\n                    result = not accept or accept(prefix)\n                    if type(result) in [str, bytes]:\n                        accept_warnings.append(result)\n                    elif result:\n                        fp.seek(0)\n                        im = factory(fp, filename)\n                        _decompression_bomb_check(im.size)\n                        return im\n                except (SyntaxError, IndexError, TypeError, struct.error):\n                    # Leave disabled by default, spams the logs with image\n                    # opening failures that are entirely expected.\n                    # logger.debug(\"\", exc_info=True)\n                    continue\n                except BaseException:\n                    if exclusive_fp:\n                        fp.close()\n                    raise\n            return None\n    \n        im = _open_core(fp, filename, prefix, formats)\n    \n        if im is None and formats is ID:\n            checked_formats = formats.copy()\n            if init():\n                im = _open_core(\n                    fp,\n                    filename,\n                    prefix,\n                    tuple(format for format in formats if format not in checked_formats),\n                )\n    \n        if im:\n            im._exclusive_fp = exclusive_fp\n            return im\n    \n        if exclusive_fp:\n            fp.close()\n        for message in accept_warnings:\n            warnings.warn(message)\n        msg = \"cannot identify image file %r\" % (filename if filename else fp)\n>       raise UnidentifiedImageError(msg)\nE       PIL.UnidentifiedImageError: cannot identify image file <_io.BytesIO object at 0x7f55d64f61b0>\n\n/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/site-packages/PIL/Image.py:3309: UnidentifiedImageError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_elements.TestElements object at 0x7f55d71287a0>\n\n    @allure.title(\"Image\")\n    def test_image(self):\n        self.broken_links.open()\n        self.broken_links.is_opened()\n        self.broken_links.check_valid_image()\n>       self.broken_links.check_broken_image()\n\ntests/test_elements.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.elements.broken_links.BrokenLinks object at 0x7f55d76257c0>\n\n    @allure.step(\"Checking the broken image\")\n    def check_broken_image(self):\n        imageSite = self.wait.until((EC.visibility_of_element_located(self.BROKEN_IMAGE)))\n        src = imageSite.get_attribute(\"src\")\n        response = requests.get(src)\n        try:\n            if response.status_code == 200:\n                image = Image.open(BytesIO(response.content))\n                assert imageSite.is_displayed(), ErrorElements.ERROR_IMAGE_NOT_DISPLAYED\n                assert image.size[0] > 16 and image.size[1] > 16, ErrorElements.ERROR_IMAGE_SIZE\n            else:\n                raise AssertionError(ErrorElements.ERROR_IMAGE)\n        except UnidentifiedImageError:\n>           raise AssertionError(ErrorElements.ERROR_FAVICON)\nE           AssertionError: ErrorElements.ERROR_FAVICON\n\npages/elements/broken_links.py:43: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1714127972493,"stop":1714127972509,"duration":16},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"tmp_path_factory","time":{"start":1714127972509,"stop":1714127972509,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"tmp_path","time":{"start":1714128000270,"stop":1714128000270,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"tmpdir","time":{"start":1714128000271,"stop":1714128000271,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"driver","time":{"start":1714128000271,"stop":1714128000458,"duration":187},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"setup","time":{"start":1714128000459,"stop":1714128000894,"duration":435},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"environment_allure","time":{"start":1714128000459,"stop":1714128000459,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false}],"testStage":{"status":"failed","statusMessage":"AssertionError: ErrorElements.ERROR_FAVICON","statusTrace":"self = <pages.elements.broken_links.BrokenLinks object at 0x7f55d76257c0>\n\n    @allure.step(\"Checking the broken image\")\n    def check_broken_image(self):\n        imageSite = self.wait.until((EC.visibility_of_element_located(self.BROKEN_IMAGE)))\n        src = imageSite.get_attribute(\"src\")\n        response = requests.get(src)\n        try:\n            if response.status_code == 200:\n>               image = Image.open(BytesIO(response.content))\n\npages/elements/broken_links.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfp = <_io.BytesIO object at 0x7f55d64f61b0>, mode = 'r'\nformats = ['BMP', 'DIB', 'GIF', 'JPEG', 'PPM', 'PNG', ...]\n\n    def open(fp, mode=\"r\", formats=None) -> Image:\n        \"\"\"\n        Opens and identifies the given image file.\n    \n        This is a lazy operation; this function identifies the file, but\n        the file remains open and the actual image data is not read from\n        the file until you try to process the data (or call the\n        :py:meth:`~PIL.Image.Image.load` method).  See\n        :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n    \n        :param fp: A filename (string), pathlib.Path object or a file object.\n           The file object must implement ``file.read``,\n           ``file.seek``, and ``file.tell`` methods,\n           and be opened in binary mode. The file object will also seek to zero\n           before reading.\n        :param mode: The mode.  If given, this argument must be \"r\".\n        :param formats: A list or tuple of formats to attempt to load the file in.\n           This can be used to restrict the set of formats checked.\n           Pass ``None`` to try all supported formats. You can print the set of\n           available formats by running ``python3 -m PIL`` or using\n           the :py:func:`PIL.features.pilinfo` function.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        :exception FileNotFoundError: If the file cannot be found.\n        :exception PIL.UnidentifiedImageError: If the image cannot be opened and\n           identified.\n        :exception ValueError: If the ``mode`` is not \"r\", or if a ``StringIO``\n           instance is used for ``fp``.\n        :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.\n        \"\"\"\n    \n        if mode != \"r\":\n            msg = f\"bad mode {repr(mode)}\"\n            raise ValueError(msg)\n        elif isinstance(fp, io.StringIO):\n            msg = (\n                \"StringIO cannot be used to open an image. \"\n                \"Binary data must be used instead.\"\n            )\n            raise ValueError(msg)\n    \n        if formats is None:\n            formats = ID\n        elif not isinstance(formats, (list, tuple)):\n            msg = \"formats must be a list or tuple\"\n            raise TypeError(msg)\n    \n        exclusive_fp = False\n        filename = \"\"\n        if isinstance(fp, Path):\n            filename = str(fp.resolve())\n        elif is_path(fp):\n            filename = fp\n    \n        if filename:\n            fp = builtins.open(filename, \"rb\")\n            exclusive_fp = True\n    \n        try:\n            fp.seek(0)\n        except (AttributeError, io.UnsupportedOperation):\n            fp = io.BytesIO(fp.read())\n            exclusive_fp = True\n    \n        prefix = fp.read(16)\n    \n        preinit()\n    \n        accept_warnings = []\n    \n        def _open_core(fp, filename, prefix, formats):\n            for i in formats:\n                i = i.upper()\n                if i not in OPEN:\n                    init()\n                try:\n                    factory, accept = OPEN[i]\n                    result = not accept or accept(prefix)\n                    if type(result) in [str, bytes]:\n                        accept_warnings.append(result)\n                    elif result:\n                        fp.seek(0)\n                        im = factory(fp, filename)\n                        _decompression_bomb_check(im.size)\n                        return im\n                except (SyntaxError, IndexError, TypeError, struct.error):\n                    # Leave disabled by default, spams the logs with image\n                    # opening failures that are entirely expected.\n                    # logger.debug(\"\", exc_info=True)\n                    continue\n                except BaseException:\n                    if exclusive_fp:\n                        fp.close()\n                    raise\n            return None\n    \n        im = _open_core(fp, filename, prefix, formats)\n    \n        if im is None and formats is ID:\n            checked_formats = formats.copy()\n            if init():\n                im = _open_core(\n                    fp,\n                    filename,\n                    prefix,\n                    tuple(format for format in formats if format not in checked_formats),\n                )\n    \n        if im:\n            im._exclusive_fp = exclusive_fp\n            return im\n    \n        if exclusive_fp:\n            fp.close()\n        for message in accept_warnings:\n            warnings.warn(message)\n        msg = \"cannot identify image file %r\" % (filename if filename else fp)\n>       raise UnidentifiedImageError(msg)\nE       PIL.UnidentifiedImageError: cannot identify image file <_io.BytesIO object at 0x7f55d64f61b0>\n\n/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/site-packages/PIL/Image.py:3309: UnidentifiedImageError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_elements.TestElements object at 0x7f55d71287a0>\n\n    @allure.title(\"Image\")\n    def test_image(self):\n        self.broken_links.open()\n        self.broken_links.is_opened()\n        self.broken_links.check_valid_image()\n>       self.broken_links.check_broken_image()\n\ntests/test_elements.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pages.elements.broken_links.BrokenLinks object at 0x7f55d76257c0>\n\n    @allure.step(\"Checking the broken image\")\n    def check_broken_image(self):\n        imageSite = self.wait.until((EC.visibility_of_element_located(self.BROKEN_IMAGE)))\n        src = imageSite.get_attribute(\"src\")\n        response = requests.get(src)\n        try:\n            if response.status_code == 200:\n                image = Image.open(BytesIO(response.content))\n                assert imageSite.is_displayed(), ErrorElements.ERROR_IMAGE_NOT_DISPLAYED\n                assert image.size[0] > 16 and image.size[1] > 16, ErrorElements.ERROR_IMAGE_SIZE\n            else:\n                raise AssertionError(ErrorElements.ERROR_IMAGE)\n        except UnidentifiedImageError:\n>           raise AssertionError(ErrorElements.ERROR_FAVICON)\nE           AssertionError: ErrorElements.ERROR_FAVICON\n\npages/elements/broken_links.py:43: AssertionError","steps":[{"name":"Open URL","time":{"start":1714128000895,"stop":1714128002514,"duration":1619},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"Check is opened URL","time":{"start":1714128002514,"stop":1714128002518,"duration":4},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"Checking the valid image","time":{"start":1714128002518,"stop":1714128003098,"duration":580},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false},{"name":"Checking the broken image","time":{"start":1714128003098,"stop":1714128003446,"duration":348},"status":"failed","statusMessage":"AssertionError: ErrorElements.ERROR_FAVICON\n","statusTrace":"  File \"/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/site-packages/allure_commons/_allure.py\", line 192, in impl\n    return func(*a, **kw)\n           ^^^^^^^^^^^^^^\n  File \"/home/runner/work/demoqa_ui/demoqa_ui/pages/elements/broken_links.py\", line 43, in check_broken_image\n    raise AssertionError(ErrorElements.ERROR_FAVICON)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":0,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":4,"attachmentsCount":0,"hasContent":true},"afterStages":[{"name":"driver::0","time":{"start":1714128003588,"stop":1714128003898,"duration":310},"status":"passed","steps":[],"attachments":[{"uid":"8ffca79b21aae81e","name":"test_image.png","source":"8ffca79b21aae81e.png","type":"image/png","size":592135}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true},{"name":"tmp_path::0","time":{"start":1714128003898,"stop":1714128003898,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false}],"labels":[{"name":"feature","value":"Elements"},{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_elements"},{"name":"subSuite","value":"TestElements"},{"name":"host","value":"fv-az1530-40"},{"name":"thread","value":"1942-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_elements"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"caeaa5c3ddc35431.json","parameterValues":[]}